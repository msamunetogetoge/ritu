# LINE Webhook アーキテクチャ検討レポート

LINE Webhook（イベント受信部分）を、既存のバックエンド（BE）APIサーバーに同居させるか、別のサーバー（Function等）として分離するかの比較検討資料です。

## 比較概要

| 項目 | A. 同居パターン (Monolith) | B. 分離パターン (Serverless/Microservice) |
| :--- | :--- | :--- |
| **構成** | 既存のAPIサーバーに `/line/webhook` ルートを追加 | Google Cloud Functions / AWS Lambda 等を別途用意 |
| **開発コスト** | **低**。既存のコード・DB・型定義をそのまま利用可能。 | **中**。DB接続設定やデプロイ設定が別途必要。コード共有の工夫が必要。 |
| **デプロイ** | 既存フローで完結。 | 別のデプロイパイプラインが必要。 |
| **コスト** | 追加費用なし（既存インスタンス内）。 | 別途Functionの実行課金（少量なら無料枠内）。 |
| **安全性** | APIサーバー全体が落ちるとWebhookも受信不可。 | APIサーバーが落ちてもWebhookは受信可能（キューイング等すれば）。 |
| **拡張性** | APIサーバーのリソースを消費。大量アクセスでAPI全体が重くなる可能性。 | Webhookの負荷がAPIサーバーに影響しない。オートスケールしやすい。 |

## 詳細分析

### A. バックエンド同居パターン (推奨)

現在の `ritu` プロジェクト（Hono + Firestore）の構成に、ルートを追加する方法です。

*   **メリット**:
    *   **実装が早い**: 既存の `UserService` や `UserRepository` を import するだけで DB 操作が可能です。
    *   **コード管理が楽**: 型定義（User型など）を共有するために別パッケージを作ったりコピーする必要がありません。
    *   **デプロイが一度で済む**: `deno task start` 等でまとめて立ち上がります。
*   **デメリット**:
    *   LINEからのアクセスが集中した場合、メインのAPIサーバー（アプリ動作）も重くなるリスクがあります（ただし現状の規模では無視できる範囲です）。

### B. 別サーバー/Functions 分離パターン

LINE Webhook 専用の小さな関数（Cloud Functions for Firebase など）を作る方法です。

*   **メリット**:
    *   **疎結合**: メインのAPIサーバーがメンテナンス中やダウンしていても、LINEの受信だけは（ログ保存など）継続できる構成にできます。
    *   **スケーラビリティ**: LINEのイベントが突発的に増えても、Functions側で勝手にスケールし、メインAPIには影響を与えません。
*   **デメリット**:
    *   **コード共有が面倒**: Firestoreへの接続初期化コードや、データ型（User型など）をこちら側にも書く（または共有ライブラリ化する）必要があります。
    *   **コールドスタート**: Functionsの場合、久しぶりのアクセスで起動に数秒かかり、LINEのタイムアウト（数秒以内）に間に合わずエラーになることがあります（定期実行などで回避可能）。

## 結論と推奨

現段階（開発初期〜中規模）では、**「A. バックエンド同居パターン」** を強く推奨します。

理由:
1.  **複雑性の排除**: 構成要素が増えるとデバッグやデプロイの手間が倍増します。
2.  **即時連携**: Webhookで受け取ったデータを即座に既存のDBに反映する要件（User ID保存）だけであれば、DBに近い場所に置くのが最もシンプルです。
3.  **移行容易性**: 将来的に負荷が問題になった場合、そのルート (`/line/webhook`) だけを切り出して Functions に移すことは難しくありません（ロジックは同じため）。

まずは同居パターンで実装し、運用上の問題が出たら分離を検討するのが無駄のないアプローチです。
